# LLM Instructions for Strings App

## About This Document

**PURPOSE**: Comprehensive reference guide for LLM agents working on the Strings application. Contains architecture, functionality, and implementation patterns for maintaining consistency.

**MAINTENANCE**: Keep updated with changes. Essential for future development work.

---

## Application Overview

**Application Name**: Strings  
**Purpose**: Web application for managing dynamic text content with a file-system-like structure where every string is a variable that can be referenced hierarchically.

### Core Concept: File System Analogy

- **Strings = Files**: Each string has content and a unique name/hash, can be referenced
- **Conditionals = Directories**: Containers holding multiple related string "files" (spawns)  
- **Variable References = File Includes**: Strings embed other strings using `{{variableName}}` syntax
- **Cascading Drawers = Deep Navigation**: Click nested variables to drill down with stacked editors

### Example Usage

Conditional variable `{{color-option}}` with spawns `{{option-1}}` (content: "blue") and `{{option-2}}` (content: "green").

String: "My favorite color is `{{color-option}}`"
- If option-1 selected → "My favorite color is blue"
- If option-2 selected → "My favorite color is green"

### Key Features

- **Every String is a Variable**: Automatic variable creation with slugified names or 6-character hash
- **Variable Embedding**: Recursive `{{variableName}}` references with circular protection
- **Conditionals**: Convert strings to directories containing multiple variations (spawns)
- **Spawn Selection**: Users select which spawn variable displays for each conditional variable
- **Controlling Conditions**: Spawn variables can auto-select based on other spawn selections
- **Inline Spawn Editing**: Edit spawn names/content directly within conditional drawer
- **Canvas Display Control**: Hide embedded strings, filter by type, toggle plaintext mode
- **Real-time Variable Detection**: Yellow boxes for new variables, purple for existing

---

## Architecture

### Frontend (Next.js 14)
- **Location**: `/frontend/`
- **Framework**: Next.js 14 with App Router, Tailwind CSS, ShadCN/UI
- **State**: React useState/useEffect, cookie-based auth
- **Pattern**: Null-safe operations (`project?.strings`)
- **Development Server**: `npm run dev` (from frontend directory)

### Backend (Django)
- **Location**: `/backend/`  
- **Framework**: Django with DRF, SQLite, session auth
- **Pattern**: Comprehensive validation with meaningful errors
- **Development Server**: 
  ```bash
  source backend/env/bin/activate
  python backend/manage.py runserver
  ```

---

## Data Models

### Core Models

1. **Project**: Container for all content (name, description, user)

2. **String**: The "file" system - every string is automatically a variable
   - **Fields**: content, project, display_name, variable_name (auto-generated), variable_hash (auto-fallback), is_conditional, is_conditional_container, controlled_by_spawn
   - **Display Name**: Human-readable name (e.g., "Welcome Message")
   - **Variable Name**: Auto-generated slug from display_name (e.g., "welcome-message") or random hash if no display_name
   - **Variable Hash**: 6-character fallback identifier (e.g., "A7B2K9")
   - **Effective Variable Name**: Returns variable_name || variable_hash
   - **Conditional Variables**: Containers that hold multiple spawn variables
   - **Spawn Variables**: Individual variations within a conditional variable
   - **Controlled By Spawn**: Optional ForeignKey to another spawn variable that controls this spawn's selection

3. **Dimension** (Legacy/Compatibility): Links conditional variables to their spawn options
   - Automatically managed by backend signals
   - Frontend now works directly with conditional/spawn variables

4. **DimensionValue** (Legacy/Compatibility): Individual spawn options for a dimension
   - Automatically synced when spawns are created/updated/deleted

### Key Relationships
- Strings reference other strings via `{{variableName}}` embedding
- Conditional variables contain spawn variables (multiple string variations)
- Spawn selection determines which content displays for conditional variables
- Controlling spawn relationships enable cascading auto-selection
- Circular reference protection prevents infinite loops

---

## User Interface

### Layout (Three Panels)

**Left - Filter Sidebar (360px)**:
- Conditional variables with display names
- Spawn variables as selectable tags beneath each conditional
- Hover-triggered edit pencil icons
- Selected spawns: Blue background
- Auto-selected spawns: Green background with "(auto)" label
- Disabled/locked spawns: Grey with "(locked)" label

**Center - Main Canvas**:
- All strings including conditionals and embedded strings
- Orange badges for conditionals, purple badges for strings
- Canvas Settings button opens right-hand drawer
- New String button for creating variables

**Right - Variables Sidebar** (collapsible): Variable management

### Canvas Settings Drawer

**Display Mode Section**:
- **Plaintext Mode**: Show resolved content without styling or conditional variables
- **Show Variables**: Display variable names as badges instead of resolved content  
- **Hide Embedded Strings** (ON by default): Hide strings used as variables or spawn variables
- **Show Variable Names** (ON by default): Display the variable name (title/display_name) on each string card
- **Show Variable Hashes** (OFF by default): Display the copiable variable hash badge on each string card

**String Type Filter Section**:
- **Show All** (default): Display both string variables and conditional variables
- **String Variables Only**: Show only regular string variables (not conditional containers)
- **Conditional Variables Only**: Show only conditional variables (the "folder" containers)

**Key Features**:
- Layered filtering: All filters work together
- Real-time updates: Canvas updates instantly
- Smart detection: Automatically identifies embedded strings

### Unified Drawer System

**Single Component Architecture**:
- `StringEditDrawer` component handles all string/conditional editing
- `useStringEditDrawer` hook manages all drawer state and operations
- `stringOperations.ts` contains consolidated save logic
- Replaces 4+ legacy drawer systems
- 60% code reduction, consistent UX across all scenarios

**Three Main Tabs**: Content, Conditions, Advanced

**Content Tab**:
- Variable Type dropdown: String or Conditional
- **String Mode**: Text content editing + variable detection boxes
- **Conditional Mode**: Spawn management with inline editing

**Conditions Tab**:
- Shows parent conditional variables (for spawn variables)
- **Controlling Condition Feature**:
  - Toggle to enable/disable
  - Dropdown to select controller spawn
  - Grouped list by parent conditional
  - Type-ahead search filtering
  - Auto-selection when controller is selected

**Advanced Tab**:
- Display Name input (triggers slugify)
- Variable Name (read-only, auto-generated)
- Variable Hash (read-only, fallback)

### Conditional Mode Features

**Inline Spawn Editing**:
- **Variable Name Input**: Always visible for all spawn types (triggers slugify on save)
- **Content Textarea**: Visible for string variables only (3 rows, resizable)
- **Conditional Spawns**: Show name input + edit button to open full drawer
- **Real-time Updates**: Changes reflected immediately in state
- **Batch Save**: All spawn edits saved together when parent conditional is saved
- **Filter Sidebar Sync**: Tags update to show new slugified names after save

**Spawn Management**:
- Yellow boxes: New/temporary spawns
- Purple boxes: Existing string variables as spawns
- Orange boxes: Existing conditional variables as spawns
- Add New Spawn button
- Add Existing Variable as Spawn (autocomplete search)
- Remove spawn button (hover-triggered)
- Include Hide Option checkbox

---

## API Endpoints

### Authentication
- `POST /api/auth/login/` - Login
- `POST /api/auth/logout/` - Logout  
- `POST /api/auth/register/` - Register
- `GET /api/auth/me/` - Current user

### Projects
- `GET /api/projects/` - List projects (ordered by -created_at)
- `POST /api/projects/` - Create project
- `GET /api/projects/{id}/` - Get project with all data
- `PATCH /api/projects/{id}/` - Update project
- `DELETE /api/projects/{id}/` - Delete project
- `POST /api/projects/{id}/duplicate/` - Duplicate project with all content

### Strings (Core API)
- `POST /api/strings/` - Create string (auto-generates variable_name from display_name using slugify)
- `PATCH /api/strings/{id}/` - Update string (auto-updates variable_name if display_name changes)
- `DELETE /api/strings/{id}/` - Delete string
- `POST /api/strings/{id}/duplicate/` - Duplicate string (preserves embedded variable references)

**String Creation/Update Payload**:
```json
{
  "content": "String content here",
  "display_name": "Welcome Message",  // Optional - generates slug: "welcome-message"
  "is_conditional": false,
  "is_conditional_container": false,
  "controlled_by_spawn_id": null,  // Optional - ID of controlling spawn variable
  "project": 1
}
// Note: variable_name is auto-generated (read-only) from display_name
// If no display_name provided, uses random 6-char hash
```

### Dimensions (Auto-managed)
- Backend signals automatically create/update/delete dimensions and dimension values
- Frontend works directly with conditional/spawn variables
- Dimensions maintained for backward compatibility

---

## Key Implementation Patterns

### State Management
```javascript
// Null-safe data access
const strings = project?.strings || [];

// Conditional spawn selection state (NEW - replaces dimension-based state)
const [selectedConditionalSpawns, setSelectedConditionalSpawns] = useState<{
  [conditionalVariableName: string]: string | null
}>({});

// Canvas display settings
const [hideEmbeddedStrings, setHideEmbeddedStrings] = useState(true);
const [showVariableNames, setShowVariableNames] = useState(true);
const [showVariableHashes, setShowVariableHashes] = useState(false);

// Unified drawer system
const mainDrawer = useStringEditDrawer({
  project,
  selectedDimensionValues,
  pendingStringVariables,
  onSuccess: () => fetchProject()
});
```

### Conditional Variable Resolution
```javascript
// Direct conditional spawn selection (NEW)
const selectedSpawnName = selectedConditionalSpawns[conditionalName];

// Find and render spawn content
if (selectedSpawnName && selectedSpawnName !== "Hidden") {
  const spawnVariable = project?.strings?.find((str: any) =>
    str.effective_variable_name === selectedSpawnName ||
    str.variable_name === selectedSpawnName ||
    str.variable_hash === selectedSpawnName
  );
  
  if (spawnVariable) {
    const spawnContent = processConditionalVariables(spawnVariable.content || '');
    processedContent = processedContent.replace(regex, spawnContent);
  }
}
```

### Slugify-Based Variable Naming
```python
# Backend: String model save() method
def save(self, *args, **kwargs):
    if self.display_name and self.display_name.strip():
        base_slug = slugify(self.display_name, max_length=50)
        self.variable_name = self.generate_unique_slug(base_slug)
    elif not self.variable_name:
        self.variable_name = self.generate_unique_hash()
    
    if not self.variable_hash:
        self.variable_hash = self.generate_unique_hash()
    
    super().save(*args, **kwargs)
```

### Controlling Spawn Relationships
```javascript
// Build bidirectional maps
const getControllingSpawnMap = () => {
  const controllerToControlled = new Map<number, number[]>();
  const controlledToController = new Map<number, number>();
  
  project.strings.forEach((str: any) => {
    if (str.controlled_by_spawn_id) {
      controlledToController.set(str.id, str.controlled_by_spawn_id);
      if (!controllerToControlled.has(str.controlled_by_spawn_id)) {
        controllerToControlled.set(str.controlled_by_spawn_id, []);
      }
      controllerToControlled.get(str.controlled_by_spawn_id)!.push(str.id);
    }
  });
  
  return { controllerToControlled, controlledToController };
};

// Auto-select controlled spawns when controller is selected
useEffect(() => {
  // ... build autoSelections map ...
  
  // Only update if there are actual changes (prevents infinite loop)
  if (Object.keys(autoSelections).length > 0) {
    const hasChanges = Object.entries(autoSelections).some(
      ([conditionalName, spawnName]) => 
        selectedConditionalSpawns[conditionalName] !== spawnName
    );
    
    if (hasChanges) {
      setSelectedConditionalSpawns(prev => ({ ...prev, ...autoSelections }));
    }
  }
}, [selectedConditionalSpawns, project?.strings]);
```

### Inline Spawn Editing
```typescript
// Component: StringEditDrawer.tsx
<Input
  value={spawn.display_name || ''}
  onChange={(e) => onUpdateSpawn?.(index, { ...spawn, display_name: e.target.value })}
  placeholder="Enter variable name"
/>

<Textarea
  value={spawn.content || ''}
  onChange={(e) => onUpdateSpawn?.(index, { ...spawn, content: e.target.value })}
  placeholder="Enter spawn content"
  rows={3}
/>

// Hook: useStringEditDrawer.ts
const updateSpawn = useCallback((index: number, updatedSpawn: any) => {
  setState(prev => ({
    ...prev,
    conditionalSpawns: prev.conditionalSpawns.map((spawn, i) => 
      i === index ? updatedSpawn : spawn
    )
  }));
}, []);

// Save logic: stringOperations.ts
const spawnPayload = {
  content: spawn.content?.trim() || 'Default spawn content',
  display_name: spawn.display_name?.trim() || null,  // Triggers slugify
  is_conditional: false,
  is_conditional_container: false,
  project: projectId,
};
```

### Error Handling
```javascript
// Graceful handling of backend pre-emptive updates
try {
  await apiFetch(`/api/dimension-values/${existingValue.id}/`, {
    method: 'DELETE',
  });
} catch (deleteError: any) {
  const errorStr = deleteError.message || String(deleteError);
  if (errorStr.includes('Not found') || errorStr.includes('404')) {
    console.log(`Already removed by backend signal, continuing...`);
  } else {
    console.error(`Failed to delete:`, deleteError);
  }
}
```

---

## Major Architectural Changes

### Dimensions Elimination (January 2025)

**Previous Architecture**:
```
User sees: "Dimensions" → "Dimension Values"
Backend:   Conditional Variable → Dimension → Dimension Values → Spawn Variables
Frontend:  selectedDimensionValues[dimensionId] = dimensionValueName
```

**New Architecture**:
```
User sees: Conditional Variables → Spawn Variables (direct)
Backend:   Conditional Variable → Spawn Variables (dimensions still exist for compatibility)
Frontend:  selectedConditionalSpawns[conditionalName] = spawnName
```

**Key Changes**:
- Filter sidebar shows actual conditional/spawn variable names
- Direct spawn selection without dimension ID lookups
- Automatic migration from old dimension state to new conditional state
- Backward compatible via fallback logic

**Benefits**:
- Simplified mental model (what you see = actual data structure)
- Reduced complexity (eliminated abstraction layer)
- Better performance (direct name lookups)
- Clearer UI ("Conditions" instead of "Dimensions")

### Unified Drawer System (January 2025)

**Consolidated**:
- 4+ duplicate drawer systems → Single `StringEditDrawer` component
- Multiple save functions → Single `saveString` function in `stringOperations.ts`
- Inconsistent interfaces → Unified 3-tab structure (Content, Conditions, Advanced)

**Results**:
- 60% code reduction
- Consistent UX across all editing scenarios
- Easier maintenance and debugging
- Single source of truth for drawer logic

---

## Working Features

### Core Functionality
- ✅ Authentication system with Django sessions
- ✅ Project management with CRUD operations
- ✅ String-as-variable system with auto-slugify generation
- ✅ Variable embedding with recursive processing
- ✅ Conditional system with spawn management
- ✅ Controlling condition relationships
- ✅ Inline spawn editing
- ✅ Circular reference protection
- ✅ Canvas display control (hide embedded, filter by type)

### UI/UX
- ✅ Three-panel responsive layout
- ✅ Unified drawer system for all editing
- ✅ Canvas Settings drawer with display/filter options
- ✅ Filter sidebar with spawn selection
- ✅ Yellow/purple/orange variable detection boxes
- ✅ Bulk operations with floating action bar
- ✅ String duplication preserving variable references

### Technical
- ✅ Idempotent operations throughout
- ✅ Comprehensive content validation
- ✅ Django signals for auto-inheritance and dimension sync
- ✅ Frontend/backend validation alignment
- ✅ Slugify-based variable naming
- ✅ Graceful error handling for race conditions

---

## Testing Focus Areas

### Critical Flows
1. **Inline Spawn Editing**: Edit spawn names/content → save → verify slugify → check filter sidebar updates
2. **Controlling Conditions**: Set controller → select controller spawn → verify auto-selection and disabled states
3. **Variable Embedding**: Multi-level A→B→C references work correctly
4. **Circular Protection**: Self-reference and loops properly blocked
5. **Canvas Filtering**: Hide embedded strings, filter by type, toggle display modes

### UI/UX
1. **Drawer System**: Unified drawer handles create/edit for strings and conditionals
2. **Filter Sidebar**: Spawn selection, auto-selection, disabled states display correctly
3. **Variable Boxes**: Yellow (new), purple (existing strings), orange (conditionals) appear correctly
4. **Canvas Settings**: All toggles and filters work together properly

---

## Development Workflow

### Git Operations
- **IMPORTANT**: Do NOT commit or push code changes unless explicitly requested by the user
- Only make the requested code changes and let the user handle git operations when ready
- User prefers to control their own commit timing and messages

### File Structure
```
frontend/src/
├── components/
│   └── StringEditDrawer.tsx          # Unified drawer component
├── hooks/
│   └── useStringEditDrawer.ts        # Unified state management
├── lib/
│   └── stringOperations.ts           # Consolidated save logic
└── app/(dashboard)/projects/[id]/
    └── page.tsx                      # Main project page
```

### Key Files
- **`page.tsx`**: Main UI, filter sidebar, canvas, state management
- **`StringEditDrawer.tsx`**: Unified drawer for all editing scenarios
- **`useStringEditDrawer.ts`**: Drawer state and operations
- **`stringOperations.ts`**: Save logic for strings and conditionals
- **`backend/strings_api/models.py`**: String model with slugify logic
- **`backend/strings_api/serializers.py`**: API serializers

---

## Recent Major Updates (2025)

### Inline Spawn Editing Feature
- Edit spawn names and content directly within conditional variable drawer
- Variable Name input for all spawn types (triggers slugify)
- Content textarea for string variables only
- Conditional spawns show name + edit button
- Batch save: all spawn edits saved together
- Filter sidebar automatically syncs with new slugified names

### Controlling Condition Feature
- Spawn variables can be controlled by other spawn variables
- When controller spawn is selected → controlled spawn auto-selects
- Sibling spawns of controlled spawn become disabled
- Visual indicators: green "(auto)" for controlled, grey "(locked)" for disabled
- Edit icons still work on disabled spawns
- Prevents infinite loops with hasChanges check

### Canvas Display Controls
- Hide Embedded Strings (ON by default)
- Show Variable Names (ON by default)
- Show Variable Hashes (OFF by default)
- String Type Filter (All/Strings Only/Conditionals Only)
- Plaintext Mode toggle
- Show Variables toggle

### Slugify-Based Variable Naming
- Display names automatically converted to URL-friendly identifiers
- Backend uses python-slugify with uniqueness handling
- Fallback to random 6-char hash if no display name
- Frontend shows live preview of generated slug
- Filter sidebar displays slugified names

### Dimensions Elimination
- Frontend UI simplified to work directly with conditional/spawn variables
- Eliminated abstract "dimensions" layer from user interface
- Backend dimensions still exist for compatibility
- Automatic migration from old state to new state
- Improved performance and clarity

---

## Implementation Guidelines

### String Variables
- Every string is automatically a variable (no opt-in)
- Orange badges for conditionals, purple badges for strings
- Always show `{{effectiveVariableName}}` with copy functionality
- All strings visible in canvas (use filters to hide embedded ones)

### Variable Embedding
- Use `{{variableName}}` syntax only
- Max 10 levels depth with visited set tracking
- Process with current spawn selections
- Validate against circular references

### Unified Drawer System
- All editing uses `StringEditDrawer` component
- `useStringEditDrawer` manages all state and operations
- Variable Type dropdown for String/Conditional selection
- Auto-repair for missing `is_conditional_container` flags
- Consolidated save logic handles all scenarios

### Content Validation
- Multiple layers: Frontend + backend validation
- Default fallbacks: Never allow empty content
- Meaningful errors: Specific validation messages
- Idempotent operations: Safe to retry

### Error Handling
- Null safety: Use `project?.strings` patterns
- Graceful degradation: Fallbacks for missing data
- User feedback: Clear error messages via toast
- Race condition handling: Check for "Not found" errors when backend signals pre-empt frontend operations

---

**CORE PRINCIPLE**: This is a file system for text content. Every string is a file, conditionals are directories, and the unified drawer system enables consistent editing throughout the hierarchy. Maintain this analogy for intuitive user experience.
