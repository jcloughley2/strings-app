# LLM Instructions for Strings App

## About This Document

**PURPOSE**: Comprehensive reference guide for LLM agents working on the Strings application. Contains architecture, functionality, and implementation patterns for maintaining consistency.

**MAINTENANCE**: Keep updated with changes. Essential for future development work.

---

## Application Overview

**Application Name**: Strings  
**Purpose**: Web application for managing dynamic text content with a file-system-like structure where every string is a variable that can be referenced hierarchically.

### Core Concept: File System Analogy

- **Strings = Files**: Each string has content and a unique name/hash, can be referenced
- **Conditionals = Directories**: Containers holding multiple related string "files" (spawns)  
- **Variable References = File Includes**: Strings embed other strings using `{{variableName}}` syntax
- **Cascading Drawers = Deep Navigation**: Click nested variables to drill down with stacked editors

### Example Usage

Conditional variable `{{color-option}}` with spawns `{{option-1}}` (content: "blue") and `{{option-2}}` (content: "green").

String: "My favorite color is `{{color-option}}`"
- If option-1 selected → "My favorite color is blue"
- If option-2 selected → "My favorite color is green"

### Key Features

- **Every String is a Variable**: Automatic variable creation with slugified names or 6-character hash
- **Variable Embedding**: Recursive `{{variableName}}` references with circular protection
- **Conditionals**: Convert strings to directories containing multiple variations (spawns)
- **Spawn Selection**: Users select which spawn variable displays for each conditional variable
- **Controlling Conditions**: Spawn variables can auto-select based on other spawn selections
- **Inline Spawn Editing**: Edit spawn names/content directly within conditional drawer
- **Inline Embedded Variable Editing**: Edit existing embedded variables' names/content directly within parent string drawer
- **Custom Content for New Variables**: Provide custom content for new embedded variables during creation
- **Nested Variable Prevention**: Validation prevents adding nested variables in inline editing contexts
- **Canvas Display Control**: Hide embedded strings, toggle variable names/hashes, plaintext mode
- **Conditions-Only Sidebar**: Conditional variables managed exclusively in left sidebar, not shown in canvas
- **Real-time Variable Detection**: Sparkles icon (✨) for new/pending variables
- **Unified Variable Hash Badges**: Click-to-copy badges with gradient backgrounds indicating variable type
- **Minimal UI**: Clean cards with shadow effects, no redundant type icons or badges

---

## Architecture

### Frontend (Next.js 14)
- **Location**: `/frontend/`
- **Framework**: Next.js 14 with App Router, Tailwind CSS, ShadCN/UI
- **State**: React useState/useEffect, cookie-based auth
- **Pattern**: Null-safe operations (`project?.strings`)
- **Development Server**: `npm run dev` (from frontend directory)

### Backend (Django)
- **Location**: `/backend/`  
- **Framework**: Django with DRF, SQLite, session auth
- **Pattern**: Comprehensive validation with meaningful errors
- **Development Server**: 
  ```bash
  source backend/env/bin/activate
  python backend/manage.py runserver
  ```

---

## Data Models

### Core Models

1. **Project**: Container for all content (name, description, user)

2. **String**: The "file" system - every string is automatically a variable
   - **Fields**: content, project, display_name, variable_name (auto-generated), variable_hash (auto-fallback), is_conditional, is_conditional_container, controlled_by_spawn
   - **Display Name**: Human-readable name (e.g., "Welcome Message")
   - **Variable Name**: Auto-generated slug from display_name (e.g., "welcome-message") or random hash if no display_name
   - **Variable Hash**: 6-character fallback identifier (e.g., "A7B2K9")
   - **Effective Variable Name**: Returns variable_name || variable_hash
   - **Conditional Variables**: Containers that hold multiple spawn variables
   - **Spawn Variables**: Individual variations within a conditional variable
   - **Controlled By Spawn**: Optional ForeignKey to another spawn variable that controls this spawn's selection

3. **Dimension** (Legacy/Compatibility): Links conditional variables to their spawn options
   - Automatically managed by backend signals
   - Frontend now works directly with conditional/spawn variables

4. **DimensionValue** (Legacy/Compatibility): Individual spawn options for a dimension
   - Automatically synced when spawns are created/updated/deleted

### Key Relationships
- Strings reference other strings via `{{variableName}}` embedding
- Conditional variables contain spawn variables (multiple string variations)
- Spawn selection determines which content displays for conditional variables
- Controlling spawn relationships enable cascading auto-selection
- Circular reference protection prevents infinite loops

---

## User Interface

### Layout (Three Panels)

**Left - Conditions Sidebar (360px)**:
- Conditional variables with display names
- Spawn variables as selectable tags beneath each conditional
- Hover-triggered edit pencil icons
- Selected spawns: Blue background
- Auto-selected spawns: Green background with "(auto)" label
- Disabled/locked spawns: Grey with "(locked)" label

**Center - Main Canvas**:
- String variables only (conditionals excluded - managed in sidebar)
- Purple badges for strings
- Canvas Settings button opens right-hand drawer
- New String button for creating variables

**Right - Variables Sidebar** (collapsible): Variable management

### Canvas Settings Drawer

**Display Mode Section**:
- **Plaintext Mode**: Show resolved content without styling or conditional variables
- **Show Variables**: Display variable names as badges instead of resolved content  
- **Hide Embedded Strings** (ON by default): Hide strings used as variables or spawn variables
- **Show Variable Names** (ON by default): Display the variable name (title/display_name) on each string card
- **Show Variable Hashes** (OFF by default): Display the copiable variable hash badge on each string card

**Key Features**:
- Real-time updates: Canvas updates instantly
- Smart detection: Automatically identifies embedded strings
- Conditional variables always hidden from canvas (managed in Conditions sidebar)

### Unified Drawer System

**Single Component Architecture**:
- `StringEditDrawer` component handles all string/conditional editing
- `useStringEditDrawer` hook manages all drawer state and operations
- `stringOperations.ts` contains consolidated save logic
- Replaces 4+ legacy drawer systems
- 60% code reduction, consistent UX across all scenarios

**Three Main Tabs**: Content, Conditions, Advanced

**Content Tab**:
- Variable Type dropdown: String or Conditional
- **String Mode**: 
  - Text content editing + variable detection boxes
  - Embedded Variables section with inline editing for existing variables
  - Custom content input for new variables (optional)
- **Conditional Mode**: Spawn management with inline editing

**Conditions Tab**:
- Shows parent conditional variables (for spawn variables)
- **Controlling Condition Feature**:
  - Toggle to enable/disable
  - Dropdown to select controller spawn
  - Grouped list by parent conditional
  - Type-ahead search filtering
  - Auto-selection when controller is selected

**Advanced Tab**:
- Display Name input (triggers slugify)
- Variable Name (read-only, auto-generated)
- Variable Hash (read-only, fallback)

### Conditional Mode Features

**Inline Spawn Editing**:
- **Variable Name Input**: Always visible for all spawn types (triggers slugify on save)
- **Content Textarea**: Visible for string variables only (3 rows, resizable)
- **Conditional Spawns**: Show name input + edit button to open full drawer
- **Real-time Updates**: Changes reflected immediately in state
- **Batch Save**: All spawn edits saved together when parent conditional is saved
- **Conditions Sidebar Sync**: Tags update to show new slugified names after save

**Spawn Management**:
- Yellow boxes: New/temporary spawns
- Purple boxes: Existing string variables as spawns
- Orange boxes: Existing conditional variables as spawns
- Add New Spawn button
- Add Existing Variable as Spawn (autocomplete search)
- Remove spawn button (hover-triggered)
- Include Hide Option checkbox

### Inline Embedded Variable Editing

**For Existing Embedded Variables**:
- Shows all embedded variables detected in parent string content
- Purple/orange tiles with icon badges
- **Variable Name Input**: Editable, triggers slugify on save
- **Content Textarea**: Editable for string variables only
- **Conditional Variables**: Read-only with edit button to open full drawer
- Changes saved when parent string is saved

**For New/Pending Embedded Variables**:
- Yellow tiles for variables detected but not yet created
- **Variable Name**: Read-only (comes from `{{variableName}}` in content)
- **Content Input**: Optional custom content field
- If left blank: Uses default content "Content for {variableName}"
- If filled: Creates variable with custom content
- Created automatically when parent string is saved

**Nested Variable Prevention**:
- Validation prevents `{{...}}` syntax in spawn/embedded variable content
- Error message guides user to open variable directly for nesting
- Applies to: spawn content, embedded variable edits, pending variable content
- Parent string content is not restricted

---

## API Endpoints

### Authentication
- `POST /api/auth/login/` - Login
- `POST /api/auth/logout/` - Logout  
- `POST /api/auth/register/` - Register
- `GET /api/auth/me/` - Current user

### Projects
- `GET /api/projects/` - List projects (ordered by -created_at)
- `POST /api/projects/` - Create project
- `GET /api/projects/{id}/` - Get project with all data
- `PATCH /api/projects/{id}/` - Update project
- `DELETE /api/projects/{id}/` - Delete project
- `POST /api/projects/{id}/duplicate/` - Duplicate project with all content

### Strings (Core API)
- `POST /api/strings/` - Create string (auto-generates variable_name from display_name using slugify)
- `PATCH /api/strings/{id}/` - Update string (auto-updates variable_name if display_name changes)
- `DELETE /api/strings/{id}/` - Delete string
- `POST /api/strings/{id}/duplicate/` - Duplicate string (preserves embedded variable references)

**String Creation/Update Payload**:
```json
{
  "content": "String content here",
  "display_name": "Welcome Message",  // Optional - generates slug: "welcome-message"
  "is_conditional": false,
  "is_conditional_container": false,
  "controlled_by_spawn_id": null,  // Optional - ID of controlling spawn variable
  "project": 1
}
// Note: variable_name is auto-generated (read-only) from display_name
// If no display_name provided, uses random 6-char hash
```

### Dimensions (Auto-managed)
- Backend signals automatically create/update/delete dimensions and dimension values
- Frontend works directly with conditional/spawn variables
- Dimensions maintained for backward compatibility

---

## Key Implementation Patterns

### State Management
```javascript
// Null-safe data access
const strings = project?.strings || [];

// Conditional spawn selection state (NEW - replaces dimension-based state)
const [selectedConditionalSpawns, setSelectedConditionalSpawns] = useState<{
  [conditionalVariableName: string]: string | null
}>({});

// Canvas display settings
const [hideEmbeddedStrings, setHideEmbeddedStrings] = useState(true);
const [showVariableNames, setShowVariableNames] = useState(true);
const [showVariableHashes, setShowVariableHashes] = useState(false);

// Unified drawer system
const mainDrawer = useStringEditDrawer({
  project,
  selectedDimensionValues,
  pendingStringVariables,
  onSuccess: () => fetchProject()
});
```

### Conditional Variable Resolution
```javascript
// Direct conditional spawn selection (NEW)
const selectedSpawnName = selectedConditionalSpawns[conditionalName];

// Find and render spawn content
if (selectedSpawnName && selectedSpawnName !== "Hidden") {
  const spawnVariable = project?.strings?.find((str: any) =>
    str.effective_variable_name === selectedSpawnName ||
    str.variable_name === selectedSpawnName ||
    str.variable_hash === selectedSpawnName
  );
  
  if (spawnVariable) {
    const spawnContent = processConditionalVariables(spawnVariable.content || '');
    processedContent = processedContent.replace(regex, spawnContent);
  }
}
```

### Slugify-Based Variable Naming
```python
# Backend: String model save() method
def save(self, *args, **kwargs):
    if self.display_name and self.display_name.strip():
        base_slug = slugify(self.display_name, max_length=50)
        self.variable_name = self.generate_unique_slug(base_slug)
    elif not self.variable_name:
        self.variable_name = self.generate_unique_hash()
    
    if not self.variable_hash:
        self.variable_hash = self.generate_unique_hash()
    
    super().save(*args, **kwargs)
```

### Controlling Spawn Relationships
```javascript
// Build bidirectional maps
const getControllingSpawnMap = () => {
  const controllerToControlled = new Map<number, number[]>();
  const controlledToController = new Map<number, number>();
  
  project.strings.forEach((str: any) => {
    if (str.controlled_by_spawn_id) {
      controlledToController.set(str.id, str.controlled_by_spawn_id);
      if (!controllerToControlled.has(str.controlled_by_spawn_id)) {
        controllerToControlled.set(str.controlled_by_spawn_id, []);
      }
      controllerToControlled.get(str.controlled_by_spawn_id)!.push(str.id);
    }
  });
  
  return { controllerToControlled, controlledToController };
};

// Auto-select controlled spawns when controller is selected
useEffect(() => {
  // ... build autoSelections map ...
  
  // Only update if there are actual changes (prevents infinite loop)
  if (Object.keys(autoSelections).length > 0) {
    const hasChanges = Object.entries(autoSelections).some(
      ([conditionalName, spawnName]) => 
        selectedConditionalSpawns[conditionalName] !== spawnName
    );
    
    if (hasChanges) {
      setSelectedConditionalSpawns(prev => ({ ...prev, ...autoSelections }));
    }
  }
}, [selectedConditionalSpawns, project?.strings]);
```

### Inline Spawn Editing
```typescript
// Component: StringEditDrawer.tsx
<Input
  value={spawn.display_name || ''}
  onChange={(e) => onUpdateSpawn?.(index, { ...spawn, display_name: e.target.value })}
  placeholder="Enter variable name"
/>

<Textarea
  value={spawn.content || ''}
  onChange={(e) => onUpdateSpawn?.(index, { ...spawn, content: e.target.value })}
  placeholder="Enter spawn content"
  rows={3}
/>

// Hook: useStringEditDrawer.ts
const updateSpawn = useCallback((index: number, updatedSpawn: any) => {
  setState(prev => ({
    ...prev,
    conditionalSpawns: prev.conditionalSpawns.map((spawn, i) => 
      i === index ? updatedSpawn : spawn
    )
  }));
}, []);

// Save logic: stringOperations.ts
const spawnPayload = {
  content: spawn.content?.trim() || 'Default spawn content',
  display_name: spawn.display_name?.trim() || null,  // Triggers slugify
  is_conditional: false,
  is_conditional_container: false,
  project: projectId,
};
```

### Inline Embedded Variable Editing
```typescript
// State management in useStringEditDrawer.ts
embeddedVariableEdits: {[variableId: string]: {display_name?: string; content?: string}};
pendingVariableContent: {[variableName: string]: string};

// Component: StringEditDrawer.tsx - Existing variables
const currentEdits = embeddedVariableEdits[stringVar.id] || {};
const currentDisplayName = currentEdits.display_name !== undefined 
  ? currentEdits.display_name 
  : (stringVar.display_name || '');

<Input
  value={currentDisplayName}
  onChange={(e) => {
    const newEdits = {
      ...embeddedVariableEdits,
      [stringVar.id]: { ...currentEdits, display_name: e.target.value }
    };
    onEmbeddedVariableEditsChange(newEdits);
  }}
/>

// Component: StringEditDrawer.tsx - Pending variables
<Textarea
  value={pendingVariableContent[variableName] || ''}
  onChange={(e) => {
    const newContent = { ...pendingVariableContent, [variableName]: e.target.value };
    onPendingVariableContentChange(newContent);
  }}
  placeholder="Enter content or leave blank for default"
/>

// Save logic: useStringEditDrawer.ts
const saveEmbeddedVariableEdits = async () => {
  for (const [variableId, edits] of Object.entries(state.embeddedVariableEdits)) {
    const payload: any = {};
    if (edits.display_name !== undefined) payload.display_name = edits.display_name?.trim() || null;
    if (edits.content !== undefined) payload.content = edits.content?.trim() || 'Default content';
    await apiFetch(`/api/strings/${variableId}/`, { method: 'PATCH', body: JSON.stringify(payload) });
  }
};

// Custom content for new variables
const customContent = state.pendingVariableContent[varName];
const content = customContent && customContent.trim() 
  ? customContent.trim() 
  : `Content for ${varName}`;
```

### Nested Variable Prevention
```typescript
// Validation in save function (useStringEditDrawer.ts)
// Check spawn content
for (const spawn of state.conditionalSpawns) {
  if (spawn.content && spawn.content.includes('{{')) {
    throw new Error(
      `Spawn variable "${spawn.display_name || 'Unnamed'}" contains embedded variables ({{...}}). ` +
      `Nested variables cannot be added in this view. Please open the variable directly.`
    );
  }
}

// Check embedded variable edits
for (const [variableId, edits] of Object.entries(state.embeddedVariableEdits)) {
  if (edits.content && edits.content.includes('{{')) {
    throw new Error(
      `Embedded variable "${varName}" contains nested variables ({{...}}). ` +
      `Please open the variable directly to add embedded variables.`
    );
  }
}

// Check pending variable content
for (const [varName, content] of Object.entries(state.pendingVariableContent)) {
  if (content && content.includes('{{')) {
    throw new Error(
      `New variable "${varName}" contains embedded variables ({{...}}). ` +
      `Please open the variable directly after creation.`
    );
  }
}
```

### Error Handling
```javascript
// Graceful handling of backend pre-emptive updates
try {
  await apiFetch(`/api/dimension-values/${existingValue.id}/`, {
    method: 'DELETE',
  });
} catch (deleteError: any) {
  const errorStr = deleteError.message || String(deleteError);
  if (errorStr.includes('Not found') || errorStr.includes('404')) {
    console.log(`Already removed by backend signal, continuing...`);
    } else {
    console.error(`Failed to delete:`, deleteError);
  }
}
```

---

## Major Architectural Changes

### Dimensions Elimination (January 2025)

**Previous Architecture**:
```
User sees: "Dimensions" → "Dimension Values"
Backend:   Conditional Variable → Dimension → Dimension Values → Spawn Variables
Frontend:  selectedDimensionValues[dimensionId] = dimensionValueName
```

**New Architecture**:
```
User sees: Conditional Variables → Spawn Variables (direct)
Backend:   Conditional Variable → Spawn Variables (dimensions still exist for compatibility)
Frontend:  selectedConditionalSpawns[conditionalName] = spawnName
```

**Key Changes**:
- Conditions sidebar shows actual conditional/spawn variable names
- Direct spawn selection without dimension ID lookups
- Automatic migration from old dimension state to new conditional state
- Backward compatible via fallback logic

**Benefits**:
- Simplified mental model (what you see = actual data structure)
- Reduced complexity (eliminated abstraction layer)
- Better performance (direct name lookups)
- Clearer UI ("Conditions" instead of "Dimensions")

### Unified Drawer System (January 2025)

**Consolidated**:
- 4+ duplicate drawer systems → Single `StringEditDrawer` component
- Multiple save functions → Single `saveString` function in `stringOperations.ts`
- Inconsistent interfaces → Unified 3-tab structure (Content, Conditions, Advanced)

**Results**:
- 60% code reduction
- Consistent UX across all editing scenarios
- Easier maintenance and debugging
- Single source of truth for drawer logic

---

## Working Features

### Core Functionality
- ✅ Authentication system with Django sessions
- ✅ Project management with CRUD operations
- ✅ String-as-variable system with auto-slugify generation
- ✅ Variable embedding with recursive processing
- ✅ Conditional system with spawn management
- ✅ Controlling condition relationships
- ✅ Inline spawn editing
- ✅ Inline embedded variable editing
- ✅ Custom content for new variables
- ✅ Nested variable prevention validation
- ✅ Circular reference protection
- ✅ Canvas display control (hide embedded, toggle names/hashes)

### UI/UX
- ✅ Three-panel responsive layout (Conditions sidebar, Canvas, Variables sidebar)
- ✅ Unified drawer system for all editing
- ✅ Canvas Settings drawer with display options
- ✅ Conditions sidebar with spawn selection (conditionals excluded from canvas)
- ✅ Yellow/purple/orange variable detection boxes
- ✅ Bulk operations with floating action bar
- ✅ String duplication preserving variable references
- ✅ Grand Hotel font for logo

### Technical
- ✅ Idempotent operations throughout
- ✅ Comprehensive content validation (including nested variable prevention)
- ✅ Django signals for auto-inheritance and dimension sync
- ✅ Frontend/backend validation alignment
- ✅ Slugify-based variable naming
- ✅ Local state management for inline editing
- ✅ Graceful error handling for race conditions

---

## Testing Focus Areas

### Critical Flows
1. **Inline Embedded Variable Editing**: Edit embedded variable names/content → save parent → verify slugify → check updates
2. **Custom Content for New Variables**: Add new variable with custom content → save → verify content persists
3. **Nested Variable Prevention**: Try adding `{{var}}` in spawn/embedded content → verify validation blocks it
4. **Inline Spawn Editing**: Edit spawn names/content → save → verify slugify → check conditions sidebar updates
5. **Controlling Conditions**: Set controller → select controller spawn → verify auto-selection and disabled states
6. **Variable Embedding**: Multi-level A→B→C references work correctly
7. **Circular Protection**: Self-reference and loops properly blocked
8. **Canvas Filtering**: Hide embedded strings, toggle names/hashes, plaintext mode

### UI/UX
1. **Drawer System**: Unified drawer handles create/edit for strings and conditionals
2. **Embedded Variables Section**: Shows existing (purple/orange) and new (yellow) variables with inline editing
3. **Conditions Sidebar**: Spawn selection, auto-selection, disabled states display correctly
4. **Canvas**: Only shows string variables (conditionals excluded)
5. **Variable Boxes**: Yellow (new), purple (existing strings), orange (conditionals) appear correctly
6. **Canvas Settings**: All toggles work together properly

---

## Development Workflow

### Git Operations
- **IMPORTANT**: Do NOT commit or push code changes unless explicitly requested by the user
- Only make the requested code changes and let the user handle git operations when ready
- User prefers to control their own commit timing and messages

### File Structure
```
frontend/src/
├── components/
│   └── StringEditDrawer.tsx          # Unified drawer component
├── hooks/
│   └── useStringEditDrawer.ts        # Unified state management
├── lib/
│   └── stringOperations.ts           # Consolidated save logic
└── app/(dashboard)/projects/[id]/
    └── page.tsx                      # Main project page
```

### Key Files
- **`page.tsx`**: Main UI, conditions sidebar, canvas, state management
- **`StringEditDrawer.tsx`**: Unified drawer for all editing scenarios
- **`VariableHashBadge.tsx`**: Reusable hash badge component with copy-to-clipboard
- **`useStringEditDrawer.ts`**: Drawer state and operations
- **`stringOperations.ts`**: Save logic for strings and conditionals
- **`backend/strings_api/models.py`**: String model with slugify logic
- **`backend/strings_api/serializers.py`**: API serializers
- **`frontend/src/styles/embedded-variables.scss`**: Centralized styling for embedded variables and hash badges
- **`frontend/src/components/ui/tooltip.tsx`**: ShadCN/UI tooltip component

---

## Embedded Variable Styling System

### Overview
All embedded variable styling is centralized in a single SCSS file for easy customization. The system uses semantic naming (based on what the element is, not how it looks) and progressive tinting for nested variables of the same type.

### File Location
- **`frontend/src/styles/embedded-variables.scss`**: All embedded variable styles
- **`frontend/src/styles/README.md`**: Customization guide

### Color Variables (Customizable)
```scss
// Edit these to change the entire color scheme
$string-var-color: blue;              // Border color for string variables
$string-text-color: black;            // Text color for string variables
$conditional-var-color: gold;         // Border color for conditional variables
$conditional-text-color: black;       // Text color for conditional variables
```

### Semantic Class Names
- **String Variables**: `.embedded-var-string-{0-4}` (not color-based like "purple")
- **Conditional Variables**: `.embedded-var-conditional-{0-4}` (not color-based like "orange")
- **Badge Mode**: `.embedded-var-badge-string`, `.embedded-var-badge-conditional`

### DRY Architecture
Uses attribute selectors to apply base styles to all depth levels:
```scss
// Base styles for ALL string variables
[class*="embedded-var-string-"] {
  color: $string-text-color;
  border-color: $string-var-color;
  padding: 0 0 4px;
}

// Only depth-specific hover backgrounds
.embedded-var-string-0:hover { background-color: tint($string-var-color, 70%); }
.embedded-var-string-1:hover { background-color: tint($string-var-color, 60%); }
// ... etc
```

### Progressive Hover Tinting
- **Depth 0**: `tint(70%)` - Very light (70% white mixed in)
- **Depth 1**: `tint(60%)` - Slightly darker
- **Depth 2**: `tint(50%)` - Medium
- **Depth 3**: `tint(40%)` - Darker
- **Depth 4**: `tint(30%)` - Darkest

### Tint/Shade Functions
Uses SCSS `mix()` function for solid colors (no transparency):
```scss
@function tint($color, $percentage) {
  @return mix(white, $color, $percentage);
}

@function shade($color, $percentage) {
  @return mix(black, $color, $percentage);
}
```

### Same-Type Nesting Logic
- **Color context tracking**: Tracks whether parent is 'string' or 'conditional'
- **Depth resets**: When variable type changes (string→conditional or vice versa), depth resets to 0
- **Progressive tinting**: Only applies when same type is nested within itself

**Example:**
```
Parent string (no color) >
  String var (depth 0, light hover) >
    Conditional var (depth 0, type changed!) >
      Conditional var (depth 1, darker hover) >
        String var (depth 0, type changed!) >
          String var (depth 1, darker hover)
```

### Border Behavior
- **Always base color**: Border color never changes, regardless of depth or hover state
- **Consistent identifier**: Acts as stable visual indicator of variable type

### TypeScript Integration
- Helper function: `getEmbeddedVarClass(type: 'string' | 'conditional', colorDepth: number)`
- Function signatures: `colorContext: 'string' | 'conditional' | null`
- Automatically applies correct class based on nesting context

---

## Recent Major Updates (2025)

### Drawer UI Refinements (Latest)
- **Unified Variable Hash Badges**: All variable hashes use `VariableHashBadge` component
  - Click-to-copy functionality throughout app
  - Gradient backgrounds: String variables (blue/teal → gray), Conditional variables (gold/salmon → gray)
  - Type-aware styling via `type` prop ('string' | 'conditional' | 'default')
  - Centralized in SCSS with `$string-var-color` and `$conditional-var-color`
- **Pending Variable Indicators**: Sparkles icon (✨) with tooltip ("Pending/New") for new variables
  - Purple color (`$pending-var-color: mediumpurple`) in SCSS
  - Replaces "New variable!" and "Existing variable" badges
- **Minimal Card Design**: 
  - Removed all type indicator icons (Plus, Spool, Folder) from variable cards
  - Unified shadow-based cards: `shadow-sm hover:shadow-md transition-all`
  - Clean borders without background colors
  - Focus on content rather than visual noise
- **Drawer Header Layout**: Variable hash badge positioned beneath title instead of side-by-side
- **Conditional Variable Editing**: Removed edit icons and messages for conditional variables in embedded/spawn lists
  - No misleading paths to edit conditionals from inline contexts
- **Tooltip Component**: Added ShadCN/UI tooltip component (`@radix-ui/react-tooltip`)

### Embedded Variable Styling System
- **Centralized SCSS file**: All embedded variable styling consolidated into `frontend/src/styles/embedded-variables.scss`
- **Semantic naming**: Classes use `string`/`conditional` instead of color names (`purple`/`orange`)
- **DRY architecture**: Attribute selectors for base styles, depth classes only define hover backgrounds
- **Customizable colors**: Four variables at top of file control entire color scheme
- **Progressive hover tinting**: Uses SCSS `mix()` function for solid colors (no transparency)
- **Same-type nesting logic**: Color depth only increments when same type is nested within itself
- **Consistent borders**: Border color always uses base color, never changes on hover or with depth
- **Easy customization**: Change entire color scheme by editing 4 variables

### Inline Embedded Variable Editing (Latest)
- Edit existing embedded variables' names/content directly within parent string drawer
- Custom content input for new embedded variables (optional, defaults to "Content for {name}")
- Purple/orange tiles for existing variables, yellow tiles for new variables
- Local state management prevents React mutation issues
- Batch save: all embedded variable edits saved together with parent string
- Nested variable prevention: Validation blocks `{{...}}` in inline editing contexts

### Canvas Simplification
- Conditional variables removed from canvas (managed exclusively in Conditions sidebar)
- Canvas now shows string variables only
- Removed String Type Filter section from Canvas Settings
- Clearer separation: strings in canvas, conditionals in sidebar
- Improved performance with fewer items to render

### Font Update
- Logo font changed from Knewave to Grand Hotel
- Elegant cursive style for more artistic feel
- Google Fonts integration via Next.js font system

### Inline Spawn Editing Feature
- Edit spawn names and content directly within conditional variable drawer
- Variable Name input for all spawn types (triggers slugify)
- Content textarea for string variables only
- Conditional spawns show name + edit button
- Batch save: all spawn edits saved together
- Conditions sidebar automatically syncs with new slugified names

### Controlling Condition Feature
- Spawn variables can be controlled by other spawn variables
- When controller spawn is selected → controlled spawn auto-selects
- Sibling spawns of controlled spawn become disabled
- Visual indicators: green "(auto)" for controlled, grey "(locked)" for disabled
- Edit icons still work on disabled spawns
- Prevents infinite loops with hasChanges check

### Canvas Display Controls
- Hide Embedded Strings (ON by default)
- Show Variable Names (ON by default)
- Show Variable Hashes (OFF by default)
- Plaintext Mode toggle
- Show Variables toggle

### Slugify-Based Variable Naming
- Display names automatically converted to URL-friendly identifiers
- Backend uses python-slugify with uniqueness handling
- Fallback to random 6-char hash if no display name
- Frontend shows live preview of generated slug
- Conditions sidebar displays slugified names

### Dimensions Elimination
- Frontend UI simplified to work directly with conditional/spawn variables
- Eliminated abstract "dimensions" layer from user interface
- Backend dimensions still exist for compatibility
- Automatic migration from old state to new state
- Improved performance and clarity

---

## Implementation Guidelines

### String Variables
- Every string is automatically a variable (no opt-in)
- Purple badges for strings (conditionals not shown in canvas)
- Always show `{{effectiveVariableName}}` with copy functionality
- Canvas shows string variables only (conditionals managed in sidebar)
- Use Canvas Settings to hide embedded strings

### Variable Embedding
- Use `{{variableName}}` syntax only
- Max 10 levels depth with visited set tracking
- Process with current spawn selections
- Validate against circular references

### Unified Drawer System
- All editing uses `StringEditDrawer` component
- `useStringEditDrawer` manages all state and operations
- Variable Type dropdown for String/Conditional selection
- Auto-repair for missing `is_conditional_container` flags
- Consolidated save logic handles all scenarios

### Content Validation
- Multiple layers: Frontend + backend validation
- Default fallbacks: Never allow empty content
- Meaningful errors: Specific validation messages
- Idempotent operations: Safe to retry

### Error Handling
- Null safety: Use `project?.strings` patterns
- Graceful degradation: Fallbacks for missing data
- User feedback: Clear error messages via toast
- Race condition handling: Check for "Not found" errors when backend signals pre-empt frontend operations

---

**CORE PRINCIPLE**: This is a file system for text content. Every string is a file, conditionals are directories, and the unified drawer system enables consistent editing throughout the hierarchy. Maintain this analogy for intuitive user experience.
